# Comparing `tmp/badgescale_ys_plt-6.0-py3-none-any.whl.zip` & `tmp/badgescale_ys_plt-7.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,30 @@
-Zip file size: 1841168 bytes, number of entries: 28
+Zip file size: 1841446 bytes, number of entries: 28
 -rw-rw-rw-  2.0 fat      120 b- defN 23-May-06 15:53 badgescale_ys_plt/__init__.py
--rw-rw-rw-  2.0 fat     1771 b- defN 23-May-09 01:33 badgescale_ys_plt/audio_playback.py
--rw-rw-rw-  2.0 fat      424 b- defN 23-May-04 04:01 badgescale_ys_plt/bidirectional_convert_icon.png
--rw-rw-rw-  2.0 fat     4366 b- defN 23-May-06 18:29 badgescale_ys_plt/ble_wrapper.py
--rw-rw-rw-  2.0 fat     2709 b- defN 23-May-06 18:02 badgescale_ys_plt/http_file_server_wrapper.py
--rw-rw-rw-  2.0 fat     2066 b- defN 23-May-06 18:02 badgescale_ys_plt/iperf_wrapper.py
--rw-rw-rw-  2.0 fat    21347 b- defN 23-May-09 07:31 badgescale_ys_plt/main_window.py
+-rw-rw-rw-  2.0 fat     1837 b- defN 23-May-09 07:52 badgescale_ys_plt/audio_playback.py
+-rw-rw-rw-  2.0 fat      424 b- defN 23-May-09 07:52 badgescale_ys_plt/bidirectional_convert_icon.png
+-rw-rw-rw-  2.0 fat     4366 b- defN 23-May-09 07:52 badgescale_ys_plt/ble_wrapper.py
+-rw-rw-rw-  2.0 fat     2786 b- defN 23-May-09 07:52 badgescale_ys_plt/http_file_server_wrapper.py
+-rw-rw-rw-  2.0 fat     2138 b- defN 23-May-09 07:52 badgescale_ys_plt/iperf_wrapper.py
+-rw-rw-rw-  2.0 fat    21624 b- defN 23-May-09 07:52 badgescale_ys_plt/main_window.py
 -rw-rw-rw-  2.0 fat        9 b- defN 23-Apr-28 20:18 badgescale_ys_plt/package_data.dat
--rw-rw-rw-  2.0 fat    11865 b- defN 23-May-09 01:23 badgescale_ys_plt/proto_wrapper.py
+-rw-rw-rw-  2.0 fat    12222 b- defN 23-May-09 07:52 badgescale_ys_plt/proto_wrapper.py
 -rw-rw-rw-  2.0 fat    32896 b- defN 23-Apr-28 23:14 badgescale_ys_plt/resource.py
 -rw-rw-rw-  2.0 fat     2613 b- defN 23-Apr-28 20:18 badgescale_ys_plt/scan_qrcode_wrapper.py
 -rw-rw-rw-  2.0 fat       43 b- defN 22-Sep-19 16:17 badgescale_ys_plt/simple.py
--rw-rw-rw-  2.0 fat    11656 b- defN 23-May-09 05:30 badgescale_ys_plt/simple_http_server.py
+-rw-rw-rw-  2.0 fat    11656 b- defN 23-May-09 07:52 badgescale_ys_plt/simple_http_server.py
 -rw-rw-rw-  2.0 fat     2969 b- defN 23-Apr-28 20:18 badgescale_ys_plt/sn_csv_table_wrapper.py
--rw-rw-rw-  2.0 fat    73508 b- defN 23-May-05 14:11 badgescale_ys_plt/speaker_sample.wav
--rw-rw-rw-  2.0 fat      124 b- defN 23-May-09 03:09 badgescale_ys_plt/summary_report_template.csv
--rw-rw-rw-  2.0 fat      518 b- defN 23-May-09 06:42 badgescale_ys_plt/table_report.py
--rw-rw-rw-  2.0 fat  3539372 b- defN 16-Apr-21 14:14 badgescale_ys_plt/iperf3/cygwin1.dll
--rw-rw-rw-  2.0 fat   468748 b- defN 16-Jun-09 02:30 badgescale_ys_plt/iperf3/iperf3.exe
--rw-rw-rw-  2.0 fat    65214 b- defN 23-May-08 06:14 badgescale_ys_plt/mic_utils/mic_uniformity_check.exe
--rw-rw-rw-  2.0 fat   326694 b- defN 23-May-08 13:13 badgescale_ys_plt/mic_utils/vibration.wav
--rw-rw-rw-  2.0 fat        9 b- defN 23-Apr-28 20:18 badgescale_ys_plt-6.0.data/data/badgescale_ys_plt_data/data_file
--rw-rw-rw-  2.0 fat     1100 b- defN 23-May-09 07:37 badgescale_ys_plt-6.0.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     9425 b- defN 23-May-09 07:37 badgescale_ys_plt-6.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-09 07:37 badgescale_ys_plt-6.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       47 b- defN 23-May-09 07:37 badgescale_ys_plt-6.0.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       18 b- defN 23-May-09 07:37 badgescale_ys_plt-6.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2629 b- defN 23-May-09 07:37 badgescale_ys_plt-6.0.dist-info/RECORD
-28 files, 4582352 bytes uncompressed, 1836834 bytes compressed:  59.9%
+-rw-rw-rw-  2.0 fat    73508 b- defN 23-May-09 07:52 badgescale_ys_plt/speaker_sample.wav
+-rw-rw-rw-  2.0 fat      124 b- defN 23-May-09 07:52 badgescale_ys_plt/summary_report_template.csv
+-rw-rw-rw-  2.0 fat      551 b- defN 23-May-09 07:52 badgescale_ys_plt/table_report.py
+-rw-rw-rw-  2.0 fat  3539372 b- defN 23-May-09 07:52 badgescale_ys_plt/iperf3/cygwin1.dll
+-rw-rw-rw-  2.0 fat   468748 b- defN 23-May-09 07:52 badgescale_ys_plt/iperf3/iperf3.exe
+-rw-rw-rw-  2.0 fat    65214 b- defN 23-May-09 07:52 badgescale_ys_plt/mic_utils/mic_uniformity_check.exe
+-rw-rw-rw-  2.0 fat   326694 b- defN 23-May-09 07:52 badgescale_ys_plt/mic_utils/vibration.wav
+-rw-rw-rw-  2.0 fat        9 b- defN 23-Apr-28 20:18 badgescale_ys_plt-7.0.data/data/badgescale_ys_plt_data/data_file
+-rw-rw-rw-  2.0 fat     1100 b- defN 23-May-09 07:52 badgescale_ys_plt-7.0.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     9425 b- defN 23-May-09 07:52 badgescale_ys_plt-7.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-09 07:52 badgescale_ys_plt-7.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       47 b- defN 23-May-09 07:52 badgescale_ys_plt-7.0.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       18 b- defN 23-May-09 07:52 badgescale_ys_plt-7.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2629 b- defN 23-May-09 07:52 badgescale_ys_plt-7.0.dist-info/RECORD
+28 files, 4583234 bytes uncompressed, 1837112 bytes compressed:  59.9%
```

## zipnote {}

```diff
@@ -57,29 +57,29 @@
 
 Filename: badgescale_ys_plt/mic_utils/mic_uniformity_check.exe
 Comment: 
 
 Filename: badgescale_ys_plt/mic_utils/vibration.wav
 Comment: 
 
-Filename: badgescale_ys_plt-6.0.data/data/badgescale_ys_plt_data/data_file
+Filename: badgescale_ys_plt-7.0.data/data/badgescale_ys_plt_data/data_file
 Comment: 
 
-Filename: badgescale_ys_plt-6.0.dist-info/LICENSE.txt
+Filename: badgescale_ys_plt-7.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: badgescale_ys_plt-6.0.dist-info/METADATA
+Filename: badgescale_ys_plt-7.0.dist-info/METADATA
 Comment: 
 
-Filename: badgescale_ys_plt-6.0.dist-info/WHEEL
+Filename: badgescale_ys_plt-7.0.dist-info/WHEEL
 Comment: 
 
-Filename: badgescale_ys_plt-6.0.dist-info/entry_points.txt
+Filename: badgescale_ys_plt-7.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: badgescale_ys_plt-6.0.dist-info/top_level.txt
+Filename: badgescale_ys_plt-7.0.dist-info/top_level.txt
 Comment: 
 
-Filename: badgescale_ys_plt-6.0.dist-info/RECORD
+Filename: badgescale_ys_plt-7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## badgescale_ys_plt/audio_playback.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-"""这是一个封装WAV音频播放的模块。
-它依赖软件包 pyaudio。
-"""
-import time
-import os
-import sys
-import pyaudio
-import wave
-import asyncio
-from uuid import uuid1
-from datetime import datetime
-
-class AudioPlayback(object):
-    """Open speaker device.
-    Then play the stream data.
-    """
-    def __init__(self):
-        self._local_path = ''
-        self._wf = None
-        self._p = None
-        self._stream = None
-
-    @property
-    def local_path(self):
-        return self._local_path
-
-    @local_path.setter
-    def local_path(self, path):
-        self._local_path = path
-        
-    def start_playback(self):
-        self._wf = wave.open(self._local_path, 'rb')
-        self._p = pyaudio.PyAudio()
-
-        self._stream = self._p.open(format=self._p.get_format_from_width(self._wf.getsampwidth()),
-                        channels=self._wf.getnchannels(),
-                        rate=self._wf.getframerate(),
-                        output=True,
-                        stream_callback=self._stream_callback)
-        
-        self._stream.start_stream()
-        return True
-
-    def stop_playback(self):
-        while self._stream.is_active():
-            time.sleep(0.1)
-        
-        self._stream.stop_stream()
-        self._stream.close()
-        self._wf.close()
-        self._p.terminate()
-        return True
-
-    def _stream_callback(self, in_data, frame_count, time_info, status):
-        data = self._wf.readframes(frame_count)
-        return data, pyaudio.paContinue
-
-
-if __name__ == "__main__":
-    ap = AudioPlayback()
-
-    from importlib.resources import files
-    ap.local_path = files('badgescale_ys_plt').joinpath('mic_utils/vibration.wav').__str__()
-    print(ap.local_path)
-
-    ap.start_playback()
+"""这是一个封装WAV音频播放的模块。
+它依赖软件包 pyaudio。
+"""
+import time
+import os
+import sys
+import pyaudio
+import wave
+import asyncio
+from uuid import uuid1
+from datetime import datetime
+
+class AudioPlayback(object):
+    """Open speaker device.
+    Then play the stream data.
+    """
+    def __init__(self):
+        self._local_path = ''
+        self._wf = None
+        self._p = None
+        self._stream = None
+
+    @property
+    def local_path(self):
+        return self._local_path
+
+    @local_path.setter
+    def local_path(self, path):
+        self._local_path = path
+        
+    def start_playback(self):
+        self._wf = wave.open(self._local_path, 'rb')
+        self._p = pyaudio.PyAudio()
+
+        self._stream = self._p.open(format=self._p.get_format_from_width(self._wf.getsampwidth()),
+                        channels=self._wf.getnchannels(),
+                        rate=self._wf.getframerate(),
+                        output=True,
+                        stream_callback=self._stream_callback)
+        
+        self._stream.start_stream()
+        return True
+
+    def stop_playback(self):
+        while self._stream.is_active():
+            time.sleep(0.1)
+        
+        self._stream.stop_stream()
+        self._stream.close()
+        self._wf.close()
+        self._p.terminate()
+        return True
+
+    def _stream_callback(self, in_data, frame_count, time_info, status):
+        data = self._wf.readframes(frame_count)
+        return data, pyaudio.paContinue
+
+
+if __name__ == "__main__":
+    ap = AudioPlayback()
+
+    from importlib.resources import files
+    ap.local_path = files('badgescale_ys_plt').joinpath('mic_utils/vibration.wav').__str__()
+    print(ap.local_path)
+
+    ap.start_playback()
     ap.stop_playback()
```

## badgescale_ys_plt/http_file_server_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,77 +1,77 @@
-"""这是一个封装http file 上传和下载服务接口的模块。
-它依赖simple_http_server模块。
-"""
-
-import subprocess
-import threading
-import psutil
-import signal
-import shutil, os
-import time
-
-class HttpFileUploadDownloadWrapper(object):
-    ip = ''
-    port = 8000
-    proc = None
-
-    def start_server():
-        if HttpFileUploadDownloadWrapper.proc is None:
-            HttpFileUploadDownloadWrapper.ip = HttpFileUploadDownloadWrapper._get_active_ip()
-            print('ip:', HttpFileUploadDownloadWrapper.ip)
-
-            HttpFileUploadDownloadWrapper.proc = subprocess.Popen(['python', '-m', 'badgescale_ys_plt.simple_http_server', '-b', '%s' % HttpFileUploadDownloadWrapper.ip, '%s' % HttpFileUploadDownloadWrapper.port], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-            print('http file server pid:', HttpFileUploadDownloadWrapper.proc.pid)
-
-            from importlib.resources import files
-            speaker_sample_file = files('badgescale_ys_plt').joinpath('speaker_sample.wav')
-            print('speaker sample:', speaker_sample_file)
-            src_basename = os.path.basename(speaker_sample_file)
-            dest_file = os.path.join(os.path.abspath('.'), src_basename)
-
-            if os.path.exists(speaker_sample_file):
-                shutil.copyfile(speaker_sample_file, dest_file)
-
-        return (HttpFileUploadDownloadWrapper.ip, HttpFileUploadDownloadWrapper.port)
-
-    def stop_server():
-        if HttpFileUploadDownloadWrapper.proc:
-            # print('before terminate')
-            # HttpFileUploadDownloadWrapper.proc.terminate()
-            # print('after terminate')
-            # print('before wait')
-            # HttpFileUploadDownloadWrapper.proc.wait()
-            # print('after wait')
-            subprocess.call(['taskkill', '/F', '/T', '/PID', str(HttpFileUploadDownloadWrapper.proc.pid)])
-            HttpFileUploadDownloadWrapper.proc = None
-
-    def _get_active_ip():
-        stats = psutil.net_if_stats()
-        nic = None
-        for k, v in stats.items():
-            if k.startswith('WLAN') and v.isup is True:
-                nic = k
-                break
-        
-        if nic:
-            addrs = psutil.net_if_addrs().get(nic)
-            for i in addrs:
-                if i.family == 2:
-                    return i.address
-
-        return None
-
-
-def signal_handler(signal, frame):
-    print("You choose to stop me.")
-    exit()
-
-def main():
-    signal.signal(signal.SIGINT, signal_handler)
-    signal.signal(signal.SIGTERM, signal_handler)
-
-    HttpFileUploadDownloadWrapper.start_server()
-    time.sleep(3600)
-    HttpFileUploadDownloadWrapper.stop_server()
-
-if __name__ == '__main__':
-    main()
+"""这是一个封装http file 上传和下载服务接口的模块。
+它依赖simple_http_server模块。
+"""
+
+import subprocess
+import threading
+import psutil
+import signal
+import shutil, os
+import time
+
+class HttpFileUploadDownloadWrapper(object):
+    ip = ''
+    port = 8000
+    proc = None
+
+    def start_server():
+        if HttpFileUploadDownloadWrapper.proc is None:
+            HttpFileUploadDownloadWrapper.ip = HttpFileUploadDownloadWrapper._get_active_ip()
+            print('ip:', HttpFileUploadDownloadWrapper.ip)
+
+            HttpFileUploadDownloadWrapper.proc = subprocess.Popen(['python', '-m', 'badgescale_ys_plt.simple_http_server', '-b', '%s' % HttpFileUploadDownloadWrapper.ip, '%s' % HttpFileUploadDownloadWrapper.port], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+            print('http file server pid:', HttpFileUploadDownloadWrapper.proc.pid)
+
+            from importlib.resources import files
+            speaker_sample_file = files('badgescale_ys_plt').joinpath('speaker_sample.wav')
+            print('speaker sample:', speaker_sample_file)
+            src_basename = os.path.basename(speaker_sample_file)
+            dest_file = os.path.join(os.path.abspath('.'), src_basename)
+
+            if os.path.exists(speaker_sample_file):
+                shutil.copyfile(speaker_sample_file, dest_file)
+
+        return (HttpFileUploadDownloadWrapper.ip, HttpFileUploadDownloadWrapper.port)
+
+    def stop_server():
+        if HttpFileUploadDownloadWrapper.proc:
+            # print('before terminate')
+            # HttpFileUploadDownloadWrapper.proc.terminate()
+            # print('after terminate')
+            # print('before wait')
+            # HttpFileUploadDownloadWrapper.proc.wait()
+            # print('after wait')
+            subprocess.call(['taskkill', '/F', '/T', '/PID', str(HttpFileUploadDownloadWrapper.proc.pid)])
+            HttpFileUploadDownloadWrapper.proc = None
+
+    def _get_active_ip():
+        stats = psutil.net_if_stats()
+        nic = None
+        for k, v in stats.items():
+            if k.startswith('WLAN') and v.isup is True:
+                nic = k
+                break
+        
+        if nic:
+            addrs = psutil.net_if_addrs().get(nic)
+            for i in addrs:
+                if i.family == 2:
+                    return i.address
+
+        return None
+
+
+def signal_handler(signal, frame):
+    print("You choose to stop me.")
+    exit()
+
+def main():
+    signal.signal(signal.SIGINT, signal_handler)
+    signal.signal(signal.SIGTERM, signal_handler)
+
+    HttpFileUploadDownloadWrapper.start_server()
+    time.sleep(3600)
+    HttpFileUploadDownloadWrapper.stop_server()
+
+if __name__ == '__main__':
+    main()
```

## badgescale_ys_plt/iperf_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,72 +1,72 @@
-"""这是一个封装iperf server操作接口的模块。
-它依赖windows二进制程序iperf3.exe。
-"""
-
-import subprocess
-import threading
-import psutil
-import signal
-import time
-import os
-
-from importlib.resources import files
-iperf3_exe = files('badgescale_ys_plt').joinpath('iperf3/iperf3.exe')
-
-class IperfWrapper(object):
-    ip = ''
-    port = 5201
-    thread1 = None
-    proc = None
-
-    def start_server():
-        if IperfWrapper.proc is None:
-            IperfWrapper.ip = IperfWrapper._get_active_ip()
-            print('ip:', IperfWrapper.ip)
-            global iperf3_exe
-            IperfWrapper.proc = subprocess.Popen([iperf3_exe, '-s', '-B', '%s' % IperfWrapper.ip, '-p', '%s' % IperfWrapper.port], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-
-            print('iper server pid:', IperfWrapper.proc.pid)
-            
-        return (IperfWrapper.ip, IperfWrapper.port)
-
-    def stop_server():
-        if IperfWrapper.proc:
-            # print('before terminate')
-            # IperfWrapper.proc.terminate()
-            # print('after terminate')
-            # print('before wait')
-            # IperfWrapper.proc.wait()
-            # print('after wait')
-            subprocess.call(['taskkill', '/F', '/T', '/PID', str(IperfWrapper.proc.pid)])
-            IperfWrapper.proc = None
-
-    def _get_active_ip():
-        stats = psutil.net_if_stats()
-        nic = None
-        for k, v in stats.items():
-            if k.startswith('WLAN') and v.isup is True:
-                nic = k
-                break
-        
-        if nic:
-            addrs = psutil.net_if_addrs().get(nic)
-            for i in addrs:
-                if i.family == 2:
-                    return i.address
-
-        return None
-
-def signal_handler(signal, frame):
-    print("You choose to stop me.")
-    exit()
-
-def main():
-    signal.signal(signal.SIGINT, signal_handler)
-    signal.signal(signal.SIGTERM, signal_handler)
-
-    IperfWrapper.start_server()
-    time.sleep(3600)
-    IperfWrapper.stop_server()
-
-if __name__ == '__main__':
-    main()
+"""这是一个封装iperf server操作接口的模块。
+它依赖windows二进制程序iperf3.exe。
+"""
+
+import subprocess
+import threading
+import psutil
+import signal
+import time
+import os
+
+from importlib.resources import files
+iperf3_exe = files('badgescale_ys_plt').joinpath('iperf3/iperf3.exe')
+
+class IperfWrapper(object):
+    ip = ''
+    port = 5201
+    thread1 = None
+    proc = None
+
+    def start_server():
+        if IperfWrapper.proc is None:
+            IperfWrapper.ip = IperfWrapper._get_active_ip()
+            print('ip:', IperfWrapper.ip)
+            global iperf3_exe
+            IperfWrapper.proc = subprocess.Popen([iperf3_exe, '-s', '-B', '%s' % IperfWrapper.ip, '-p', '%s' % IperfWrapper.port], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+
+            print('iper server pid:', IperfWrapper.proc.pid)
+            
+        return (IperfWrapper.ip, IperfWrapper.port)
+
+    def stop_server():
+        if IperfWrapper.proc:
+            # print('before terminate')
+            # IperfWrapper.proc.terminate()
+            # print('after terminate')
+            # print('before wait')
+            # IperfWrapper.proc.wait()
+            # print('after wait')
+            subprocess.call(['taskkill', '/F', '/T', '/PID', str(IperfWrapper.proc.pid)])
+            IperfWrapper.proc = None
+
+    def _get_active_ip():
+        stats = psutil.net_if_stats()
+        nic = None
+        for k, v in stats.items():
+            if k.startswith('WLAN') and v.isup is True:
+                nic = k
+                break
+        
+        if nic:
+            addrs = psutil.net_if_addrs().get(nic)
+            for i in addrs:
+                if i.family == 2:
+                    return i.address
+
+        return None
+
+def signal_handler(signal, frame):
+    print("You choose to stop me.")
+    exit()
+
+def main():
+    signal.signal(signal.SIGINT, signal_handler)
+    signal.signal(signal.SIGTERM, signal_handler)
+
+    IperfWrapper.start_server()
+    time.sleep(3600)
+    IperfWrapper.stop_server()
+
+if __name__ == '__main__':
+    main()
```

## badgescale_ys_plt/main_window.py

```diff
@@ -93,19 +93,19 @@
             [sg.Text('9.墨水屏', size = text_test_name_size), sg.Input('请人工目检，然后填写结果', readonly=True, key='-sink_screen_test_result-'), sg.Radio('合格', 'choice9', default=False, enable_events=True, key='-choice9_pass-'), sg.Radio('不合格', 'choice9', default=True, enable_events=True, key='-choice9_fail-')],
             [sg.Text('10.电池', size = text_test_name_size), sg.Input('请人工目检，然后填写结果', readonly=True, key='-battery_test_result-'), sg.Radio('合格', 'choice10', default=False, enable_events=True, key='-choice10_pass-'), sg.Radio('不合格', 'choice10', default=True, enable_events=True, key='-choice10_fail-')],
             [sg.Button('开始测试', enable_events=True, key='-start_test-'), sg.Button('停止测试', enable_events=True, key='-stop_test-', disabled=True)],
             [sg.Text('测试统计和报告')],
             [sg.Multiline('此处显示统计结果', disabled=True, key='-test_report-', size=(50,3)), sg.Button('下载报告', enable_events=True, key='-download-')]]
         
         tab3 = [[sg.Text('软件介绍')],
-            [sg.Multiline(default_text='此处...', disabled=True, key='-intro-', size = multiline_about_size)],
+            [sg.Multiline(default_text='badgescale-ys-plt全称是badge scale yunsi production line tool，解释是专门针对工牌整机的生产测试工具，工作在上位机PC Windows上。', disabled=True, key='-intro-', size = multiline_about_size)],
             [sg.Text('版权声明')],
-            [sg.Multiline(default_text='此处...', disabled=True, key='-copyright-', size = multiline_about_size)],
+            [sg.Multiline(default_text='深圳鱼亮科技有限公司版权所有,2023-2023\nCopyright © Shenzhen Bothlent Technology Co,Ltd.,2023-2023', disabled=True, key='-copyright-', size = multiline_about_size)],
             [sg.Text('联系我们')],
-            [sg.Multiline(default_text='此处...', disabled=True, key='-contact-', size = multiline_about_size)]]
+            [sg.Multiline(default_text='Name:Yebean\nWeichat:Num446844655', disabled=True, key='-contact-', size = multiline_about_size)]]
 
         tabgroup1 = sg.TabGroup([[sg.Tab('扫二维码', tab1, key='-tab1-'), 
             sg.Tab('功能测试', tab2, key='-tab2-'),
             sg.Tab('关于', tab3, key='-tab3-')]],
             key='-tabgroup1-', 
             tab_location='lefttop',
             enable_events = True)
```

## badgescale_ys_plt/proto_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,358 +1,358 @@
-"""这是一个封装串口通信接口、私有串口消息通信的模块。
-它依赖pyserial模块。
-"""
-
-import serial
-from serial.tools.list_ports import *
-from threading import Thread, Lock, Event
-import re
-import time
-
-class ProtoWrapper:
-    def __init__(self, port, baud, bytesize, stopbits, parity, auto_port=True):
-        self.port = [port]
-        self.baud = int(baud)
-        self.bytesize = None
-        if bytesize == '8':
-           self.bytesize = serial.EIGHTBITS 
-        self.stopbits = None
-        if stopbits == '1':
-            self.stopbits = serial.STOPBITS_ONE
-        self.parity = None
-        if parity == 'N':
-            self.parity = serial.PARITY_NONE
-        elif parity == 'E':
-            self.parity = serial.PARITY_EVEN
-        elif parity == 'O':
-            self.parity = serial.PARITY_ODD
-        else:
-            pass
-        self.auto_port = auto_port
-
-        self.thread1 = None
-        self.fd = None
-        self.fd_rw_lock = Lock()
-        
-        self.result_map = { }
-        
-        self.event1 = Event()
-        self.event2 = Event()
-        self.event3 = Event()
-        self.event4 = Event()
-        self.event5 = Event()
-        self.event6 = Event()
-        self.event7 = Event()
-        self.event8 = Event()
-        self.event9 = Event()
-        self.event10 = Event()
-        self.event11 = Event()
-
-        self.stopped = False
-
-    def start_read(self):
-        if self.thread1 is None:
-            self.thread1 = Thread(target = self._read_entry, name='start read thread')
-            self.thread1.start()
-            self.stopped = False
-
-    def stop_read(self):
-        self.stopped = True
-        if self.thread1:
-            self.thread1.join()
-            self.thread1 = None
-            
-    def _read_entry(self):
-        
-        while self.stopped is False:
-            if not self.fd:
-                if self.auto_port:
-                    self.port = self.get_com_list()
-                    print('port:', self.port)
-        
-                for p in self.port:
-                    try:
-                        self.fd_rw_lock.acquire()
-                        self.fd = serial.Serial(p, self.baud, self.bytesize, self.parity, self.stopbits, timeout = 1)
-                        if self.fd.isOpen():
-                            break
-                    except serial.SerialException as e:
-                        print('error:', e)
-                        self.fd = None
-                    finally:
-                        self.fd_rw_lock.release()
-                
-            while self.fd and self.fd.isOpen() and self.stopped is False:
-                str_line = ''
-                try:
-                    self.fd_rw_lock.acquire()
-                    # readline return byte-formatted data
-                    data = self.fd.readline()
-                    str_line = data.decode(encoding='utf-8', errors='ignore')
-                    str_line = str_line.strip()
-                    print('str_line:', str_line)
-                except serial.SerialTimeoutException as e:
-                    print('timeout:', e)
-                except serial.SerialException as e:
-                    print('error:', e)
-                    self.fd.close()
-                    self.fd = None
-                finally:
-                    self.fd_rw_lock.release()
-
-                if len(str_line) > 0:
-                    '''match each pattern against line just readed.'''
-                    m = re.match(r'.*?functiontest return (\d)', str_line)
-                    if m:
-                        self.response_functiontest_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest ble return (.+)', str_line)
-                    if m:
-                        self.response_functiontest_ble_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest wifi set return (\d)', str_line)
-                    if m:
-                        self.response_functiontest_wifi_set(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest wifi return TX (.+?)Mb/s', str_line)
-                    if m:
-                        self.response_functiontest_wifi_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest record return (.+)', str_line)
-                    if m:
-                        #print('note record matched')
-                        self.response_functiontest_record_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest 3dsensor return (\d)', str_line)
-                    if m:
-                        self.response_functiontest_3dsensor_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest charging return (\d)', str_line)
-                    if m:
-                        self.response_functiontest_charging_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest speaker return (\d)', str_line)
-                    if m:
-                        self.response_functiontest_speaker_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest buzzer return (\d)', str_line)
-                    if m:
-                        self.response_functiontest_buzzer_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest 3key return (\d)', str_line)
-                    if m:
-                        self.response_functiontest_3key_start(m.groups()[0])
-                    
-                    m = re.match(r'.*?functiontest return (\d)', str_line)
-                    if m:
-                        self.response_functiontest_stop(m.groups()[0])
-            
-            time.sleep(2)
-
-    def writeline(self, str):
-        self.fd_rw_lock.acquire()
-        if self.fd:
-            try:
-                self.fd.write(''.join([str, '\r\n']).encode('utf-8'))
-            except serial.SerialException as e:
-                print('error:', e)
-                self.fd = None
-        self.fd_rw_lock.release()
-    
-    @staticmethod
-    def get_com_list():
-        coms = []
-        plist = list(comports())
-        for port in plist:
-            msg =list(port)
-            coms.append(msg[0])
-        return coms
-    
-    def request_functiontest_start(self):
-        self.event1.clear()
-
-        self.writeline('functiontest start')
-        
-        if self.event1.wait(20):
-            ret = self.result_map['functiontest_start'][0]
-            return int(ret)
-        else:
-            return 1
-
-    def response_functiontest_start(self, *args):
-        self.result_map['functiontest_start'] = args
-        self.event1.set()
-
-    def request_functiontest_ble_start(self):
-        self.event2.clear()
-
-        self.writeline('functiontest ble start')
-
-        self.event2.wait(20)
-        if self.event2.isSet():
-            ret = self.result_map['functiontest_ble_start'][0]
-            return ret
-        else:
-            return ''
-
-    def response_functiontest_ble_start(self, *args):
-        self.result_map['functiontest_ble_start'] = args
-        self.event2.set()
-        
-    def request_functiontest_wifi_set(self, ssid, password):
-        self.event3.clear()
-
-        self.writeline('functiontest wifi set %s %s' % (ssid, password))
-
-        self.event3.wait(20)
-        if self.event3.isSet():
-            ret = self.result_map['functiontest_wifi_set'][0]
-            return int(ret)
-        else:
-            return 1
-
-    def response_functiontest_wifi_set(self, *args):
-        self.result_map['functiontest_wifi_set'] = args
-        self.event3.set()
-
-    def request_functiontest_wifi_start(self, ip, port):
-        self.event4.clear()
-
-        self.writeline('functiontest wifi start %s %s' % (ip, port))
-        
-        self.event4.wait(20)
-        if self.event4.isSet():
-            ret = self.result_map['functiontest_wifi_start'][0]
-            return float(ret)
-        else:
-            return 0.0
-
-    def response_functiontest_wifi_start(self, *args):
-        self.result_map['functiontest_wifi_start'] = args
-        self.event4.set()
-
-    def request_functiontest_record_start(self, ip, port):
-        self.event5.clear()
-
-        self.writeline('functiontest record start %s %s' % (ip, port))
-        
-        self.event5.wait(20)
-        if self.event5.isSet():
-            #print('note wait true')
-            ret = self.result_map['functiontest_record_start'][0]
-            return ret
-        else:
-            return ''
-
-    def response_functiontest_record_start(self, *args):
-        self.result_map['functiontest_record_start'] = args
-        self.event5.set()
-        #print('note set true')
-    
-    def request_functiontest_3dsensor_start(self):
-        self.event6.clear()
-
-        self.writeline('functiontest 3dsensor start')
-        
-        self.event6.wait(20)
-        if self.event6.isSet():
-            ret = self.result_map['functiontest_3dsensor_start'][0]
-            return int(ret)
-        else:
-            return 1
-
-    def response_functiontest_3dsensor_start(self, *args):
-        self.result_map['functiontest_3dsensor_start'] = args
-        self.event6.set()
-
-    def request_functiontest_charging_start(self):
-        self.event7.clear()
-
-        self.writeline('functiontest charging start')
-        
-        self.event7.wait(20)
-        if self.event7.isSet():
-            ret = self.result_map['functiontest_charging_start'][0]
-            return int(ret)
-        else:
-            return 1
-
-    def response_functiontest_charging_start(self, *args):
-        self.result_map['functiontest_charging_start'] = args
-        self.event7.set()
-
-    def request_functiontest_speaker_start(self, url):
-        self.event8.clear()
-
-        self.writeline('functiontest speaker start %s' % (url))
-        
-        self.event8.wait(20)
-        if self.event8.isSet():
-            ret = self.result_map['functiontest_speaker_start'][0]
-            return int(ret)
-        else:
-            return 1
-
-    def response_functiontest_speaker_start(self, *args):
-        self.result_map['functiontest_speaker_start'] = args
-        self.event8.set()
-
-    def request_functiontest_buzzer_start(self):
-        self.event9.clear()
-
-        self.writeline('functiontest buzzer start')
-
-        self.event9.wait(20)
-        if self.event9.isSet():
-            ret = self.result_map['functiontest_buzzer_start'][0]
-            return int(ret)
-        else:
-            return 1
-
-    def response_functiontest_buzzer_start(self, *args):
-        self.result_map['functiontest_buzzer_start'] = args
-        self.event9.set()
-
-    def request_functiontest_3key_start(self):
-        self.event10.clear()
-
-        self.writeline('functiontest 3key start')
-
-        self.event10.wait(20)
-        if self.event10.isSet():
-            ret = self.result_map['functiontest_3key_start'][0]
-            return int(ret)
-        else:
-            return 4
-
-    def response_functiontest_3key_start(self, *args):
-        self.result_map['functiontest_3key_start'] = args
-        self.event10.set()
-
-    def request_functiontest_stop(self):
-        self.event11.clear()
-
-        self.writeline('functiontest stop')
-        
-        self.event11.wait(20)
-        if self.event11.isSet():
-            ret = self.result_map['functiontest_stop'][0]
-            return int(ret)
-        else:
-            return 1
-
-    def response_functiontest_stop(self, *args):
-        self.result_map['functiontest_stop'] = args
-        self.event11.set()
-
-if __name__ == "__main__":
-    proto = ProtoWrapper('', 115200, '8', '1', 'N', True)
-    proto.start_read()
-    
-    print('result:', proto.request_functiontest_start())
-    time.sleep(1)
-
-    print('result:', proto.request_functiontest_ble_start())
-    time.sleep(1)
-    
-    while True:
+"""这是一个封装串口通信接口、私有串口消息通信的模块。
+它依赖pyserial模块。
+"""
+
+import serial
+from serial.tools.list_ports import *
+from threading import Thread, Lock, Event
+import re
+import time
+
+class ProtoWrapper:
+    def __init__(self, port, baud, bytesize, stopbits, parity, auto_port=True):
+        self.port = [port]
+        self.baud = int(baud)
+        self.bytesize = None
+        if bytesize == '8':
+           self.bytesize = serial.EIGHTBITS 
+        self.stopbits = None
+        if stopbits == '1':
+            self.stopbits = serial.STOPBITS_ONE
+        self.parity = None
+        if parity == 'N':
+            self.parity = serial.PARITY_NONE
+        elif parity == 'E':
+            self.parity = serial.PARITY_EVEN
+        elif parity == 'O':
+            self.parity = serial.PARITY_ODD
+        else:
+            pass
+        self.auto_port = auto_port
+
+        self.thread1 = None
+        self.fd = None
+        self.fd_rw_lock = Lock()
+        
+        self.result_map = { }
+        
+        self.event1 = Event()
+        self.event2 = Event()
+        self.event3 = Event()
+        self.event4 = Event()
+        self.event5 = Event()
+        self.event6 = Event()
+        self.event7 = Event()
+        self.event8 = Event()
+        self.event9 = Event()
+        self.event10 = Event()
+        self.event11 = Event()
+
+        self.stopped = False
+
+    def start_read(self):
+        if self.thread1 is None:
+            self.thread1 = Thread(target = self._read_entry, name='start read thread')
+            self.thread1.start()
+            self.stopped = False
+
+    def stop_read(self):
+        self.stopped = True
+        if self.thread1:
+            self.thread1.join()
+            self.thread1 = None
+            
+    def _read_entry(self):
+        
+        while self.stopped is False:
+            if not self.fd:
+                if self.auto_port:
+                    self.port = self.get_com_list()
+                    print('port:', self.port)
+        
+                for p in self.port:
+                    try:
+                        self.fd_rw_lock.acquire()
+                        self.fd = serial.Serial(p, self.baud, self.bytesize, self.parity, self.stopbits, timeout = 1)
+                        if self.fd.isOpen():
+                            break
+                    except serial.SerialException as e:
+                        print('error:', e)
+                        self.fd = None
+                    finally:
+                        self.fd_rw_lock.release()
+                
+            while self.fd and self.fd.isOpen() and self.stopped is False:
+                str_line = ''
+                try:
+                    self.fd_rw_lock.acquire()
+                    # readline return byte-formatted data
+                    data = self.fd.readline()
+                    str_line = data.decode(encoding='utf-8', errors='ignore')
+                    str_line = str_line.strip()
+                    print('str_line:', str_line)
+                except serial.SerialTimeoutException as e:
+                    print('timeout:', e)
+                except serial.SerialException as e:
+                    print('error:', e)
+                    self.fd.close()
+                    self.fd = None
+                finally:
+                    self.fd_rw_lock.release()
+
+                if len(str_line) > 0:
+                    '''match each pattern against line just readed.'''
+                    m = re.match(r'.*?functiontest return (\d)', str_line)
+                    if m:
+                        self.response_functiontest_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest ble return (.+)', str_line)
+                    if m:
+                        self.response_functiontest_ble_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest wifi set return (\d)', str_line)
+                    if m:
+                        self.response_functiontest_wifi_set(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest wifi return TX (.+?)Mb/s', str_line)
+                    if m:
+                        self.response_functiontest_wifi_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest record return (.+)', str_line)
+                    if m:
+                        #print('note record matched')
+                        self.response_functiontest_record_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest 3dsensor return (\d)', str_line)
+                    if m:
+                        self.response_functiontest_3dsensor_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest charging return (\d)', str_line)
+                    if m:
+                        self.response_functiontest_charging_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest speaker return (\d)', str_line)
+                    if m:
+                        self.response_functiontest_speaker_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest buzzer return (\d)', str_line)
+                    if m:
+                        self.response_functiontest_buzzer_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest 3key return (\d)', str_line)
+                    if m:
+                        self.response_functiontest_3key_start(m.groups()[0])
+                    
+                    m = re.match(r'.*?functiontest return (\d)', str_line)
+                    if m:
+                        self.response_functiontest_stop(m.groups()[0])
+            
+            time.sleep(2)
+
+    def writeline(self, str):
+        self.fd_rw_lock.acquire()
+        if self.fd:
+            try:
+                self.fd.write(''.join([str, '\r\n']).encode('utf-8'))
+            except serial.SerialException as e:
+                print('error:', e)
+                self.fd = None
+        self.fd_rw_lock.release()
+    
+    @staticmethod
+    def get_com_list():
+        coms = []
+        plist = list(comports())
+        for port in plist:
+            msg =list(port)
+            coms.append(msg[0])
+        return coms
+    
+    def request_functiontest_start(self):
+        self.event1.clear()
+
+        self.writeline('functiontest start')
+        
+        if self.event1.wait(20):
+            ret = self.result_map['functiontest_start'][0]
+            return int(ret)
+        else:
+            return 1
+
+    def response_functiontest_start(self, *args):
+        self.result_map['functiontest_start'] = args
+        self.event1.set()
+
+    def request_functiontest_ble_start(self):
+        self.event2.clear()
+
+        self.writeline('functiontest ble start')
+
+        self.event2.wait(20)
+        if self.event2.isSet():
+            ret = self.result_map['functiontest_ble_start'][0]
+            return ret
+        else:
+            return ''
+
+    def response_functiontest_ble_start(self, *args):
+        self.result_map['functiontest_ble_start'] = args
+        self.event2.set()
+        
+    def request_functiontest_wifi_set(self, ssid, password):
+        self.event3.clear()
+
+        self.writeline('functiontest wifi set %s %s' % (ssid, password))
+
+        self.event3.wait(20)
+        if self.event3.isSet():
+            ret = self.result_map['functiontest_wifi_set'][0]
+            return int(ret)
+        else:
+            return 1
+
+    def response_functiontest_wifi_set(self, *args):
+        self.result_map['functiontest_wifi_set'] = args
+        self.event3.set()
+
+    def request_functiontest_wifi_start(self, ip, port):
+        self.event4.clear()
+
+        self.writeline('functiontest wifi start %s %s' % (ip, port))
+        
+        self.event4.wait(20)
+        if self.event4.isSet():
+            ret = self.result_map['functiontest_wifi_start'][0]
+            return float(ret)
+        else:
+            return 0.0
+
+    def response_functiontest_wifi_start(self, *args):
+        self.result_map['functiontest_wifi_start'] = args
+        self.event4.set()
+
+    def request_functiontest_record_start(self, ip, port):
+        self.event5.clear()
+
+        self.writeline('functiontest record start %s %s' % (ip, port))
+        
+        self.event5.wait(20)
+        if self.event5.isSet():
+            #print('note wait true')
+            ret = self.result_map['functiontest_record_start'][0]
+            return ret
+        else:
+            return ''
+
+    def response_functiontest_record_start(self, *args):
+        self.result_map['functiontest_record_start'] = args
+        self.event5.set()
+        #print('note set true')
+    
+    def request_functiontest_3dsensor_start(self):
+        self.event6.clear()
+
+        self.writeline('functiontest 3dsensor start')
+        
+        self.event6.wait(20)
+        if self.event6.isSet():
+            ret = self.result_map['functiontest_3dsensor_start'][0]
+            return int(ret)
+        else:
+            return 1
+
+    def response_functiontest_3dsensor_start(self, *args):
+        self.result_map['functiontest_3dsensor_start'] = args
+        self.event6.set()
+
+    def request_functiontest_charging_start(self):
+        self.event7.clear()
+
+        self.writeline('functiontest charging start')
+        
+        self.event7.wait(20)
+        if self.event7.isSet():
+            ret = self.result_map['functiontest_charging_start'][0]
+            return int(ret)
+        else:
+            return 1
+
+    def response_functiontest_charging_start(self, *args):
+        self.result_map['functiontest_charging_start'] = args
+        self.event7.set()
+
+    def request_functiontest_speaker_start(self, url):
+        self.event8.clear()
+
+        self.writeline('functiontest speaker start %s' % (url))
+        
+        self.event8.wait(20)
+        if self.event8.isSet():
+            ret = self.result_map['functiontest_speaker_start'][0]
+            return int(ret)
+        else:
+            return 1
+
+    def response_functiontest_speaker_start(self, *args):
+        self.result_map['functiontest_speaker_start'] = args
+        self.event8.set()
+
+    def request_functiontest_buzzer_start(self):
+        self.event9.clear()
+
+        self.writeline('functiontest buzzer start')
+
+        self.event9.wait(20)
+        if self.event9.isSet():
+            ret = self.result_map['functiontest_buzzer_start'][0]
+            return int(ret)
+        else:
+            return 1
+
+    def response_functiontest_buzzer_start(self, *args):
+        self.result_map['functiontest_buzzer_start'] = args
+        self.event9.set()
+
+    def request_functiontest_3key_start(self):
+        self.event10.clear()
+
+        self.writeline('functiontest 3key start')
+
+        self.event10.wait(20)
+        if self.event10.isSet():
+            ret = self.result_map['functiontest_3key_start'][0]
+            return int(ret)
+        else:
+            return 4
+
+    def response_functiontest_3key_start(self, *args):
+        self.result_map['functiontest_3key_start'] = args
+        self.event10.set()
+
+    def request_functiontest_stop(self):
+        self.event11.clear()
+
+        self.writeline('functiontest stop')
+        
+        self.event11.wait(20)
+        if self.event11.isSet():
+            ret = self.result_map['functiontest_stop'][0]
+            return int(ret)
+        else:
+            return 1
+
+    def response_functiontest_stop(self, *args):
+        self.result_map['functiontest_stop'] = args
+        self.event11.set()
+
+if __name__ == "__main__":
+    proto = ProtoWrapper('', 115200, '8', '1', 'N', True)
+    proto.start_read()
+    
+    print('result:', proto.request_functiontest_start())
+    time.sleep(1)
+
+    print('result:', proto.request_functiontest_ble_start())
+    time.sleep(1)
+    
+    while True:
         time.sleep(1)
```

## badgescale_ys_plt/table_report.py

 * *Ordering differences only*

```diff
@@ -1,34 +1,34 @@
-import os
-import pandas as pd
-from datetime import datetime
-import time
-
-def main():
-    df = pd.DataFrame(
-        {
-            "Name": [],
-            "Age": [],
-            "Sex": []
-        }
-    )
-
-    print(df,'\n')
-
-    df.loc['0', 'Name'] = 'n0'
-
-    df.loc['1', 'Name'] = 'n1'
-    
-    df.loc['1', 'Age'] = 'a1'
-    
-    df.loc['2', 'Sex'] = 's2'
-    
-    print(df,'\n')
-
-def main2():
-    d1 = datetime.now()
-    time.sleep(3)
-    d2 = datetime.now()
-    print (d2-d1)
-
-if __name__ == '__main__':
+import os
+import pandas as pd
+from datetime import datetime
+import time
+
+def main():
+    df = pd.DataFrame(
+        {
+            "Name": [],
+            "Age": [],
+            "Sex": []
+        }
+    )
+
+    print(df,'\n')
+
+    df.loc['0', 'Name'] = 'n0'
+
+    df.loc['1', 'Name'] = 'n1'
+    
+    df.loc['1', 'Age'] = 'a1'
+    
+    df.loc['2', 'Sex'] = 's2'
+    
+    print(df,'\n')
+
+def main2():
+    d1 = datetime.now()
+    time.sleep(3)
+    d2 = datetime.now()
+    print (d2-d1)
+
+if __name__ == '__main__':
     main2()
```

## Comparing `badgescale_ys_plt-6.0.dist-info/LICENSE.txt` & `badgescale_ys_plt-7.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `badgescale_ys_plt-6.0.dist-info/METADATA` & `badgescale_ys_plt-7.0.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: badgescale-ys-plt
-Version: 6.0
+Version: 7.0
 Summary: A production line tool project
 Home-page: 
 Author: Yebean
 Author-email: bcui@bothlent.com
 Project-URL: Bug Reports, https://github.com/pypa/sampleproject/issues
 Project-URL: Funding, https://donate.pypi.org
 Project-URL: Say Thanks!, http://saythanks.io/to/example
```

