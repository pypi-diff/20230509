# Comparing `tmp/teelebot-2.0.3-py3-none-any.whl.zip` & `tmp/teelebot-2.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,20 @@
-Zip file size: 36814 bytes, number of entries: 18
+Zip file size: 38194 bytes, number of entries: 18
 -rw-rw-rw-  2.0 fat     4126 b- defN 23-May-07 14:53 teelebot/__init__.py
--rw-rw-rw-  2.0 fat      159 b- defN 23-May-03 15:15 teelebot/__main__.py
--rw-rw-rw-  2.0 fat    27942 b- defN 23-May-07 16:23 teelebot/bot.py
--rw-rw-rw-  2.0 fat     7366 b- defN 23-May-03 18:10 teelebot/buffer.py
--rw-rw-rw-  2.0 fat    19377 b- defN 23-May-07 16:46 teelebot/handler.py
+-rw-rw-rw-  2.0 fat      165 b- defN 23-May-08 17:02 teelebot/__main__.py
+-rw-rw-rw-  2.0 fat    31926 b- defN 23-May-09 03:02 teelebot/bot.py
+-rw-rw-rw-  2.0 fat     7802 b- defN 23-May-09 00:52 teelebot/buffer.py
+-rw-rw-rw-  2.0 fat    21867 b- defN 23-May-09 03:04 teelebot/handler.py
 -rw-rw-rw-  2.0 fat     1807 b- defN 23-May-03 00:00 teelebot/logger.py
 -rw-rw-rw-  2.0 fat      721 b- defN 23-May-03 00:01 teelebot/polling.py
 -rw-rw-rw-  2.0 fat     3700 b- defN 23-May-07 14:53 teelebot/request.py
--rw-rw-rw-  2.0 fat     3895 b- defN 23-May-06 02:35 teelebot/schedule.py
--rw-rw-rw-  2.0 fat      482 b- defN 23-May-07 16:51 teelebot/version.py
+-rw-rw-rw-  2.0 fat     4075 b- defN 23-May-09 01:15 teelebot/schedule.py
+-rw-rw-rw-  2.0 fat      482 b- defN 23-May-09 01:11 teelebot/version.py
 -rw-rw-rw-  2.0 fat     2665 b- defN 23-May-03 15:18 teelebot/webhook.py
--rw-rw-rw-  2.0 fat    35823 b- defN 23-May-07 16:54 teelebot-2.0.3.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     9052 b- defN 23-May-07 16:54 teelebot-2.0.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-07 16:54 teelebot-2.0.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       43 b- defN 23-May-07 16:54 teelebot-2.0.3.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        9 b- defN 23-May-07 16:54 teelebot-2.0.3.dist-info/top_level.txt
--rw-rw-rw-  2.0 fat        2 b- defN 23-May-07 16:54 teelebot-2.0.3.dist-info/zip-safe
--rw-rw-r--  2.0 fat     1406 b- defN 23-May-07 16:54 teelebot-2.0.3.dist-info/RECORD
-18 files, 118667 bytes uncompressed, 34536 bytes compressed:  70.9%
+-rw-rw-rw-  2.0 fat    35823 b- defN 23-May-09 03:26 teelebot-2.1.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     9052 b- defN 23-May-09 03:26 teelebot-2.1.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-09 03:26 teelebot-2.1.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       43 b- defN 23-May-09 03:26 teelebot-2.1.0.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        9 b- defN 23-May-09 03:26 teelebot-2.1.0.dist-info/top_level.txt
+-rw-rw-rw-  2.0 fat        2 b- defN 23-May-09 03:26 teelebot-2.1.0.dist-info/zip-safe
+-rw-rw-r--  2.0 fat     1406 b- defN 23-May-09 03:26 teelebot-2.1.0.dist-info/RECORD
+18 files, 125763 bytes uncompressed, 35916 bytes compressed:  71.4%
```

## zipnote {}

```diff
@@ -27,29 +27,29 @@
 
 Filename: teelebot/version.py
 Comment: 
 
 Filename: teelebot/webhook.py
 Comment: 
 
-Filename: teelebot-2.0.3.dist-info/LICENSE
+Filename: teelebot-2.1.0.dist-info/LICENSE
 Comment: 
 
-Filename: teelebot-2.0.3.dist-info/METADATA
+Filename: teelebot-2.1.0.dist-info/METADATA
 Comment: 
 
-Filename: teelebot-2.0.3.dist-info/WHEEL
+Filename: teelebot-2.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: teelebot-2.0.3.dist-info/entry_points.txt
+Filename: teelebot-2.1.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: teelebot-2.0.3.dist-info/top_level.txt
+Filename: teelebot-2.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: teelebot-2.0.3.dist-info/zip-safe
+Filename: teelebot-2.1.0.dist-info/zip-safe
 Comment: 
 
-Filename: teelebot-2.0.3.dist-info/RECORD
+Filename: teelebot-2.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## teelebot/__main__.py

```diff
@@ -1,9 +1,10 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2019-8-23
-@last modification: 2023-05-03
+@last modification: 2023-05-09
 '''
-import teelebot
 
 if __name__ == "__main__":
+    import teelebot
+
     teelebot.main()
```

## teelebot/bot.py

```diff
@@ -1,25 +1,27 @@
 # -*- coding:utf-8 -*-
 """
 @description:基于Telegram Bot Api 的机器人框架
 @creation date: 2019-08-13
-@last modification: 2023-05-08
+@last modification: 2023-05-09
 @author: Pluto (github:plutobell)
-@version: 2.0.3
+@version: 2.1.0
 """
 import time
 import sys
 import os
 import types
 import string
 import random
 import shutil
+import inspect
 import importlib
 
 from pathlib import Path
+from typing import Union, Callable
 from concurrent.futures import ThreadPoolExecutor
 
 from .handler import _config, _bridge, _plugin_info
 from .logger import _logger
 from .schedule import _Schedule
 from .buffer import _Buffer
 from .request import _Request
@@ -128,24 +130,24 @@
         self.__method_name = method_name
         
         return types.MethodType(self.__method_function, self)
 
     def __method_function(self, *args, **kwargs):
         # command = inspect.stack()[0].function
         if self._debug and len(args) != 1:
-            _logger.error("Method '" + self.__method_name + "' does not accept positional arguments")
+            _logger.error(f"Method '{self.__method_name}' does not accept positional arguments")
 
         return self.request.postEverything(self.__method_name, **kwargs)
 
     def __threadpool_exception(self, fur):
         """
         线程池异常回调
         """
         if fur.exception() is not None:
-            _logger.debug("EXCEPTION" + " - " + str(fur.result()))
+            _logger.debug(f"EXCEPTION - {str(fur.result())}")
 
     def __import_module(self, plugin_name):
         """
         动态导入模块
         """
         sys.path.append(self.path_converter(self.__plugin_dir + plugin_name + os.sep))
         Module = importlib.import_module(plugin_name)  # 模块检测
@@ -168,52 +170,52 @@
         # print(now_mtime, self.__plugin_info[plugin_name])
         if now_mtime != plugin_info[plugin_name]:  # 插件热更新
             if os.path.exists(self.path_converter(self.__plugin_dir + plugin_name + r"/__pycache__")):
                 shutil.rmtree(self.path_converter(self.__plugin_dir + plugin_name + r"/__pycache__"))
             plugin_info[plugin_name] = now_mtime
             Module = self.__import_module(plugin_name)
             importlib.reload(Module)
-            _logger.info("The plugin " + plugin_name + " has been updated")
+            _logger.info(f"The plugin {plugin_name} has been updated")
 
     def __load_plugin(self, now_plugin_info, as_plugin=True,
         now_plugin_bridge={}, now_non_plugin_list=[]):
         """
         动态装载插件
         """
         if as_plugin:
             for plugin in list(now_plugin_bridge.keys()): # 动态装载插件
                 if plugin not in list(self.__plugin_bridge.keys()):
-                    _logger.info("The plugin " + plugin + " has been installed")
+                    _logger.info(f"The plugin {plugin} has been installed")
                     self.__plugin_info[plugin] = now_plugin_info[plugin]
             for plugin in list(self.__plugin_bridge.keys()):
                 if plugin not in list(now_plugin_bridge.keys()):
-                    _logger.info("The plugin " + plugin + " has been uninstalled")
+                    _logger.info(f"The plugin {plugin} has been uninstalled")
                     self.__plugin_info.pop(plugin)
 
                     if (self.__plugin_dir + plugin) in sys.path:
                         sys.path.remove(self.__plugin_dir + plugin)
                     if (self.__plugin_dir + plugin) in sys.modules:
                         sys.modules.pop(self.__plugin_dir + plugin)
 
             self.__plugin_bridge = now_plugin_bridge
 
             self.buffer._update(now_plugin_bridge.keys()) # Buffer动态更新
 
         else:
             for plugin in list(now_non_plugin_list): # 动态装载非插件包
                 if plugin not in list(self.__non_plugin_list):
-                    _logger.info("The plugin " + plugin + " has been installed")
+                    _logger.info(f"The plugin {plugin} has been installed")
                     self.__non_plugin_info[plugin] = now_plugin_info[plugin]
 
                     if (self.__plugin_dir + plugin) not in sys.path:
                         sys.path.append(self.__plugin_dir + plugin)
 
             for plugin in list(self.__non_plugin_list):
                 if plugin not in list(now_non_plugin_list):
-                    _logger.info("The plugin " + plugin + " has been uninstalled")
+                    _logger.info(f"The plugin {plugin} has been uninstalled")
                     self.__non_plugin_info.pop(plugin)
 
                     if (self.__plugin_dir + plugin) in sys.path:
                         sys.path.remove(self.__plugin_dir + plugin)
                     if (self.__plugin_dir + plugin) in sys.modules:
                         sys.modules.pop(self.__plugin_dir + plugin)
 
@@ -429,18 +431,21 @@
 
         for plugin, command in plugin_bridge.items():
             if message_type == "query":
                 if command in ["", " ", None]:
                     continue
 
             if message.get(message_type)[:len(command)] == command:
-                module = self.__import_module(plugin)
-                pluginFunc = getattr(module, plugin)
-                fur = self.__thread_pool.submit(pluginFunc, bot, message)
-                fur.add_done_callback(self.__threadpool_exception)
+                try:
+                    module = self.__import_module(plugin)
+                    pluginFunc = getattr(module, plugin)
+                    fur = self.__thread_pool.submit(pluginFunc, bot, message)
+                    fur.add_done_callback(self.__threadpool_exception)
+                except Exception as e:
+                    _logger.error(f"Run plugin {plugin} error: {str(e)}")
 
                 self.__response_times += 1
 
                 if message["chat"]["type"] != "private" and \
                 message["chat"]["id"] not in self.__response_chats:
                     self.__response_chats.append(message["chat"]["id"])
                 if message["from"]["id"] not in self.__response_users:
@@ -520,15 +525,15 @@
         if len(update_ids) >= 1:
             self._offset = max(update_ids) + 1
             return messages
         else:
             return None
     
     # teelebot method
-    def message_deletor(self, time_gap, chat_id, message_id):
+    def message_deletor(self, time_gap: int, chat_id: str, message_id: str) -> str:
         """
         定时删除一条消息，时间范围：[0, 900],单位秒
         """
         if time_gap < 0 or time_gap > 900:
             return "time_gap_error"
         else:
             def message_deletor_func(time_gap, chat_id, message_id):
@@ -540,15 +545,15 @@
             else:
                 fur = self.__timer_thread_pool.submit(
                     message_deletor_func, time_gap, chat_id, message_id)
                 fur.add_done_callback(self.__threadpool_exception)
 
             return "ok"
 
-    def timer(self, time_gap, func, args):
+    def timer(self, time_gap: int, func: Callable[..., None], args: tuple) -> str:
         """
         单次定时器，时间范围：[0, 900],单位秒
         """
         if time_gap < 0 or time_gap > 900:
             return "time_gap_error"
         elif type(args) is not tuple:
             return "args_must_be_tuple"
@@ -562,42 +567,113 @@
             else:
                 fur = self.__timer_thread_pool.submit(
                     timer_func, time_gap, func, args)
                 fur.add_done_callback(self.__threadpool_exception)
 
             return "ok"
 
-    def path_converter(self, path):
+    def path_converter(self, path: str) -> str:
         """
         根据操作系统转换URI
         """
 
         path = str(Path(path))
 
         return path
     
-    def getChatCreator(self, chat_id):
+    def join_plugin_path(self, path: str, plugin_name: str = None) -> str:
+        """
+        根据提供的路径自动拼接为插件目录的URI
+        """
+        if plugin_name in [None, "", " "]:
+            plugin_name = os.path.splitext(os.path.basename(inspect.stack()[1][1]))[0]
+        
+        return self.path_converter(f"{self.plugin_dir}{plugin_name}{os.sep}{path}")
+    
+    def get_plugin_info(self, plugin_name: str = None) -> dict:
+        """
+        获取指定插件的信息
+        """
+        if plugin_name in [None, "", " "]:
+            plugin_name = os.path.splitext(os.path.basename(inspect.stack()[1][1]))[0]
+        
+        if plugin_name not in list(self.plugin_bridge.keys()):
+            info  = {
+                "status": False,
+                "error": "PluginNotFound"
+            }
+            return info
+
+        command = ""
+        description = ""
+        buffer_permissions = "Error"
+        with open(self.path_converter(f"{self.plugin_dir}{plugin_name}{os.sep}__init__.py"), "r", encoding="utf-8") as init:
+            lines = init.readlines()
+            
+            buffer_permissions_str = "False:False"
+            if len(lines) >= 1:
+                command = lines[0][1:].strip()
+            if len(lines) >= 2:
+                description = lines[1][1:].strip()
+            if len(lines) >= 3:
+                buffer_permissions_str = lines[2][1:].strip()
+
+            buffer_permissions_list = buffer_permissions_str.split(":", 1)
+            if buffer_permissions_str in [None, "", " "]:
+                buffer_permissions = tuple(False, False)
+            elif len(buffer_permissions_list) == 2:
+                bool_true = ["True", "true"]
+                bool_false = ["False", "false"]
+                read = buffer_permissions_list[0]
+                write = buffer_permissions_list[1]
+
+                if read in bool_true:
+                    read = True
+                elif read in bool_false:
+                    read = False
+                else:
+                    read = False
+                
+                if write in bool_true:
+                    write = True
+                elif write in bool_false:
+                    write = False
+                else:
+                    read = False
+
+                buffer_permissions = tuple((read, write))
+        
+        info  = {
+            "status": True,
+            "command": command,
+            "description": description,
+            "buffer_permissions": buffer_permissions
+        }
+
+        return info
+
+    def getChatCreator(self, chat_id: str) -> Union[bool, dict]:
         """
         获取群组创建者信息
         """
         if str(chat_id)[0] == "-":
-            req = self.getChatAdministrators(str(chat_id))
+            req = self.getChatAdministrators(chat_id=str(chat_id))
             if req:
                 creator = []
                 for i, user in enumerate(req):
                     if user["status"] == "creator":
                         creator.append(req[i])
                 if len(creator) == 1:
                     return creator[0]
                 else:
                     return False
         else:
             return False
 
-    def getChatMemberStatus(self, chat_id, user_id):
+    def getChatMemberStatus(self, chat_id: str, user_id: str) -> Union[bool, str]:
         """
         获取群组用户状态
         "creator",
         "administrator",
         "member",
         "restricted",
         "left",
@@ -607,15 +683,15 @@
             req = self.getChatMember(chat_id=chat_id, user_id=user_id)
 
             if req != False:
                 return req["status"]
         else:
             return False
 
-    def getFileDownloadPath(self, file_id):
+    def getFileDownloadPath(self, file_id: str) -> Union[bool, str]:
         """
         生成文件下载链接
         注意：下载链接包含Bot Key
         """
         req = self.getFile(file_id=file_id)
         if req:
             file_path = req["file_path"]
@@ -624,14 +700,42 @@
                 return file_path
             else:
                 file_download_path = self._basic_url + "file/bot" + self._key + r"/" + file_path
                 return file_download_path
         else:
             return False
 
+    def getChatAdminsUseridList(self, chat_id, skip_bot: bool = True,
+                                privilege_users: list = None) -> Union[bool, list]:
+        """
+        获取聊天中的管理员user_id列表
+        """
+        admins = []
+        results = self.getChatAdministrators(chat_id=chat_id)
+        if results != False:
+            for result in results:
+                if skip_bot:
+                    if str(result["user"]["is_bot"]) == "True":
+                        continue
+                admins.append(str(result["user"]["id"]))
+            
+            if privilege_users is not None:
+                if isinstance(privilege_users, list):
+                    privilege_str_users = []
+                    for pu in privilege_users:
+                        privilege_str_users.append(str(pu))
+                    admins = list(set(admins + privilege_str_users))
+                else:
+                    return False
+
+        else:
+            return False
+
+        return admins
+
     @property
     def plugin_bridge(self):
         """
         获取插件桥
         """
 
         return self.__plugin_bridge
```

## teelebot/buffer.py

```diff
@@ -1,16 +1,17 @@
 '''
 @creation date: 2021-04-25
-@last modification: 2023-05-03
+@last modification: 2023-05-09
 '''
 from __future__ import print_function
 from sys import getsizeof, stderr
 from itertools import chain
 from collections import deque
 from pathlib import Path
+from typing import Tuple, Union
 try:
     from reprlib import repr
 except ImportError:
     pass
 
 import threading
 import inspect
@@ -31,15 +32,15 @@
 
         for plugin_name in self.__plugin_names:
             self.__buffer[plugin_name] = {}
 
     def __del__(self):
         del self.__buffer
 
-    def status(self):
+    def status(self) -> Tuple[bool, dict]:
         """
         获取数据暂存区的使用情况
         单位为字节
         """
         try:
             with self.__buffer_mutex:
                 used = self.__total_size(self.__buffer)
@@ -51,36 +52,36 @@
                 "free": free,
                 "size": size
             }
             return True, result
         except Exception as e:
             return False, {"exception": e}
 
-    def sizeof(self, plugin_name=None):
+    def sizeof(self, plugin_name: str = None) -> Tuple[bool, Union[str, int]]:
         """
         获取单个插件数据暂存区占用内存大小
         单位为字节
         """
-        if plugin_name is None:
-            plugin_name = str(inspect.stack()[1][3])
+        if plugin_name in [None, "", " "]:
+            plugin_name = os.path.splitext(os.path.basename(inspect.stack()[1][1]))[0]
 
         if plugin_name in self.__buffer.keys():
             with self.__buffer_mutex:
                 return True, self.__total_size(self.__buffer.get(plugin_name))
         else:
             return False, "NoPlugin"
 
-    def read(self, plugin_name=None):
+    def read(self, plugin_name: str = None) -> Tuple[bool, Union[str, tuple, any]]:
         """
         从暂存区读取数据
         """
         isSelf = False
-        if plugin_name is None:
+        if plugin_name in [None, "", " "]:
             isSelf = True
-            plugin_name = str(inspect.stack()[1][3])
+            plugin_name = os.path.splitext(os.path.basename(inspect.stack()[1][1]))[0]
 
         if plugin_name in self.__buffer.keys():
             ok, permission = self.__permission_check(plugin_name)
             if ok:
                 permission_read = permission[0]
                 # permission_write = permission[1]
                 if not permission_read and not isSelf:
@@ -89,22 +90,22 @@
                 return False, permission
 
             with self.__buffer_mutex:
                 return True, copy.deepcopy(self.__buffer.get(plugin_name, {}))
         else:
             return False, "NoPlugin"
 
-    def write(self, buffer, plugin_name=None):
+    def write(self, buffer: any, plugin_name: str = None) -> Tuple[bool, Union[str, tuple]]:
         """
         写入数据到暂存区
         """
         isSelf = False
-        if plugin_name is None:
+        if plugin_name in [None, "", " "]:
             isSelf = True
-            plugin_name = str(inspect.stack()[1][3])
+            plugin_name = os.path.splitext(os.path.basename(inspect.stack()[1][1]))[0]
 
         if plugin_name in self.__buffer.keys():
             ok, permission = self.__permission_check(plugin_name)
             if ok:
                 # permission_read = permission[0]
                 permission_write = permission[1]
                 if not permission_write and not isSelf:
@@ -139,22 +140,23 @@
 
             return True
         else:
             return False
 
     def __permission_check(self, plugin_name):
         if plugin_name in self.__buffer.keys():
-            if plugin_name != str(inspect.stack()[1][3]): # 读写权限检查
+            if plugin_name != os.path.splitext(os.path.basename(inspect.stack()[1][1]))[0]: # 读写权限检查
                 with open(Path(self.__plugin_dir + plugin_name + os.sep + "__init__.py"), "r", encoding="utf-8") as init:
                     lines = init.readlines()
 
                 for i, _ in enumerate(lines):
-                    lines[i].strip("\n")
-                    lines[i].strip("\r")
-                    lines[i].strip("")
+                    lines[i] = lines[i].strip("\n")
+                    lines[i] = lines[i].strip("\r")
+                    lines[i] = lines[i].strip("")
+                    lines[i] = lines[i].strip()
 
                 if len(lines) > 2:
                     permission = lines[2][1:]
                     if lines[2] == "#":
                         permission = "False:False"
                 else:
                     permission = "False:False" # 格式 读:写
```

## teelebot/handler.py

```diff
@@ -1,11 +1,11 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2019-08-23
-@last modification: 2023-05-08
+@last modification: 2023-05-09
 '''
 import configparser
 import argparse
 import os
 import sys
 import shutil
 import requests
@@ -203,34 +203,38 @@
                     enter.writelines([
                         "# -*- coding: utf-8 -*-\n",
                         "\n",
                         "def " + plugin_name + "(bot, message):\n",
                         "\n" + \
                         "    # root_id = bot.root_id\n" + \
                         "    # bot_id = bot.bot_id\n" + \
+                        "\n" + \
                         "    # author = bot.author\n" + \
                         "    # version = bot.version\n" + \
+                        "\n" + \
                         "    # plugin_dir = bot.plugin_dir\n" + \
                         "    # plugin_bridge = bot.plugin_bridge\n" + \
+                        "\n" + \
                         "    # uptime = bot.uptime\n" + \
                         "    # response_times = bot.response_times\n" + \
                         "    # response_chats = bot.response_chats\n" + \
                         "    # response_users = bot.response_users\n" + \
                         "    # proxies = bot.proxies\n" + \
                         "\n" + \
                         '    chat_id = message["chat"]["id"]\n' + \
                         '    user_id = message["from"]["id"]\n' + \
                         '    message_id = message["message_id"]\n' + \
                         "\n" + \
                         '    message_type = message["message_type"]\n' + \
                         '    chat_type = message["chat"]["type"]\n' + \
                         "\n" + \
-                        '    prefix = ""\n' + \
-                        '    with open(bot.path_converter(bot.plugin_dir + "' + plugin_name + '/__init__.py"), "r", encoding="utf-8") as init:\n' + \
-                        '        prefix = init.readline()[1:].strip()\n' + \
+                        '    plugin_info = bot.get_plugin_info()\n' + \
+                        '    command = ""\n' + \
+                        '    if plugin_info.get("status", False):\n' + \
+                        '        command = plugin_info.get("command", "")\n' + \
                         "\n\n" + \
                         "    # Write your plugin code below"
                     ])
             if not os.path.exists(str(Path(plugin_dir + plugin_name + os.sep + "README.md"))):
                 with open(str(Path(plugin_dir + plugin_name + os.sep + "README.md")), "w", encoding='utf-8') as readme:
                     readme.writelines([
                         "# " + plugin_name + " #\n"
@@ -378,34 +382,78 @@
     non_plugin_list = []
     plugin_list = []
     corrupted_plugin_list = []
 
     plugin_lis = os.listdir(plugin_dir)
     for plugi in plugin_lis:
         if os.path.isdir(str(Path(plugin_dir + plugi))) and plugi != "__pycache__" and plugi[0] != '.':
+            entrance_exist = False
+            entrance_count = 0
+            try:
+                with open(str(Path(f"{plugin_dir}{plugi}{os.sep}{plugi}.py")), "r", encoding="utf-8") as e:
+                    content = e.read()
+                    if f"def {plugi}(bot, message):" in content or \
+                        f"def {plugi}(message, bot):" in content or \
+                        f"def {plugi}(bot,message):" in content or \
+                        f"def {plugi}(message,bot):" in content:
+                        entrance_exist = True
+
+                    if entrance_exist:
+                        entrance_count += content.count(f"def {plugi}(bot, message):")
+                        entrance_count += content.count(f"def {plugi}(message, bot):")
+                        entrance_count += content.count(f"def {plugi}(bot,message):")
+                        entrance_count += content.count(f"def {plugi}(message,bot):")
+            except Exception as e:
+                os.system("")
+                print("\033[1;31mThe " + plugi + " plugin is corrupted: " + "\033[0m" + str(e))
+
             package_file_list = os.listdir(str(Path(plugin_dir + plugi)))
             if plugi + ".py" in package_file_list and \
                 "__init__.py" in package_file_list and \
-                "METADATA" in package_file_list:
+                "METADATA" in package_file_list and \
+                entrance_exist and entrance_count == 1:
                 plugin_list.append(plugi)
             else:
-                os.system("")
-                print("\033[1;31mThe " + plugi + " plugin is corrupted." + "\033[0m")
                 corrupted_plugin_list.append(plugi)
 
+                missing_files_count = 0
+                error = f"plugin missing "
+                if f"{plugi}.py" not in package_file_list:
+                    error += f"'{plugi}.py' "
+                    missing_files_count += 1
+                if "__init__.py" not in package_file_list:
+                    error += "'__init__.py' "
+                    missing_files_count += 1
+                if "METADATA" not in package_file_list:
+                    error += "'METADATA' "
+                    missing_files_count += 1
+                if missing_files_count != 0:
+                    os.system("")
+                    print("\033[1;31mThe " + plugi + " plugin is corrupted: " + "\033[0m" + error)
+                
+                if not entrance_exist:
+                    error = f"plugin not found entrance function '{plugi}'"
+                    os.system("")
+                    print("\033[1;31mThe " + plugi + " plugin is corrupted: " + "\033[0m" + error)
+                elif entrance_exist and entrance_count != 1:
+                    error = f"multiple entrance functions exist in plugin"
+                    os.system("")
+                    print("\033[1;31mThe " + plugi + " plugin is corrupted: " + "\033[0m" + error)
+
     for plugin in plugin_list:
         with open(str(Path(plugin_dir + plugin + r"/__init__.py")), encoding="utf-8") as f:
             row_one = f.readline().strip()[1:]
             if row_one != common_pkg_prefix:  # Hidden plugin
                 plugin_bridge[plugin] = row_one
             else:
                 if plugin in corrupted_plugin_list:
                     if (plugin_dir + plugin) in sys.path:
-                        sys.modules.pop(plugin_dir + plugin)
                         sys.path.remove(plugin_dir + plugin)
+                    if (plugin_dir + plugin) in sys.modules:
+                        sys.modules.pop(plugin_dir + plugin)
                 else:
                     non_plugin_list.append(plugin)
                     if (plugin_dir + plugin) not in sys.path:
                         sys.path.append(plugin_dir + plugin)
 
     # print(sys.path)
     # print(plugin_bridge, non_plugin_list)
```

## teelebot/schedule.py

```diff
@@ -1,14 +1,15 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2019-11-15
-@last modification: 2023-05-06
+@last modification: 2023-05-09
 '''
 import threading
 from uuid import uuid4
+from typing import Tuple, Callable
 
 class _Schedule(object):
     """
     周期性任务类
     """
     def __init__(self, queue_size):
         self.__queue_size = queue_size
@@ -28,15 +29,15 @@
             t = RepeatingTimer(gap, func, args)
             t.setDaemon(True)
             return True, t
         except Exception as e:
             print("Error:", str(e))
             return False, str(e)
 
-    def add(self, gap, func, args):
+    def add(self, gap: int, func: Callable[..., None], args: tuple) -> Tuple[bool, str]:
         """
         添加周期性任务
         """
         def __short_uuid():
             uuidChars = ("a", "b", "c", "d", "e", "f",
                     "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s",
                     "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5",
@@ -61,15 +62,15 @@
             with self.__queue_mutex:
                 self.__queue[uid] = t
 
             return True, uid
         else:
             return False, t
 
-    def status(self):
+    def status(self) -> Tuple[bool, dict]:
         """
         获取周期性任务池的使用情况
         """
         try:
             with self.__queue_mutex:
                 used = len(self.__queue)
                 free = self.__queue_size - used
@@ -80,28 +81,28 @@
                 "free": free,
                 "size": size
             }
             return True, result
         except Exception as e:
             return False, {"exception": e}
 
-    def find(self, uid):
+    def find(self, uid: str) -> Tuple[bool, str]:
         """
         查找周期性任务
         """
         with self.__queue_mutex:
             if len(self.__queue) <= 0:
                 return False, "Empty"
 
             if str(uid) in self.__queue.keys():
                 return True, str(uid)
             else:
                 return False, "NotFound"
 
-    def delete(self, uid):
+    def delete(self, uid: str) -> Tuple[bool, str]:
         """
         移除周期性任务
         """
         if len(self.__queue) <= 0:
             return False, "Empty"
 
         if str(uid) in self.__queue.keys():
@@ -109,15 +110,15 @@
             with self.__queue_mutex:
                 self.__queue.pop(str(uid))
 
             return True, str(uid)
         else:
             return False, "NotFound"
 
-    def clear(self):
+    def clear(self) -> Tuple[bool, str]:
         """
         移除所有周期性任务
         """
         if len(self.__queue) == 0:
             return False, "Empty"
         else:
             try:
```

## teelebot/version.py

```diff
@@ -1,17 +1,17 @@
 # -*- coding:utf-8 -*-
 """
 @description:基于Telegram Bot Api 的机器人框架
 @creation date: 2019-11-15
-@last modification: 2023-05-08
+@last modification: 2023-05-09
 @author: Pluto (github:plutobell)
-@version: 2.0.3
+@version: 2.1.0
 """
 
-__version__ = "2.0.3"
+__version__ = "2.1.0"
 __author__ = "Pluto"
 __email__ = "hi@ojoll.com"
 __blog__ = "https://ojoll.com"
 __github__ = "https://github.com/plutobell/teelebot"
 __description__ = "teelebot is a robot framework based on Telegram Bot API, with plug-in system, easy to extend."
```

## Comparing `teelebot-2.0.3.dist-info/LICENSE` & `teelebot-2.1.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `teelebot-2.0.3.dist-info/METADATA` & `teelebot-2.1.0.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: teelebot
-Version: 2.0.3
+Version: 2.1.0
 Summary: teelebot is a robot framework based on Telegram Bot API, with plug-in system, easy to extend.
 Home-page: https://ojoll.com
 Author: Pluto
 Author-email: hi@ojoll.com
 License: GPLv3
 Keywords: teelebot telegram bot telegram bot api telegram
 Classifier: Programming Language :: Python :: 3
```

### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: teelebot Version: 2.0.3 Summary: teelebot is a
+Metadata-Version: 2.1 Name: teelebot Version: 2.1.0 Summary: teelebot is a
 robot framework based on Telegram Bot API, with plug-in system, easy to extend.
 Home-page: https://ojoll.com Author: Pluto Author-email: hi@ojoll.com License:
 GPLv3 Keywords: teelebot telegram bot telegram bot api telegram Classifier:
 Programming Language :: Python :: 3 Classifier: Operating System :: OS
 Independent Classifier: License :: OSI Approved :: GNU General Public License
 v3 (GPLv3) Requires-Python: >=3.6 Description-Content-Type: text/markdown
 License-File: LICENSE Requires-Dist: requests
```

## Comparing `teelebot-2.0.3.dist-info/RECORD` & `teelebot-2.1.0.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 teelebot/__init__.py,sha256=_RulqeVSYAqRhTaljCZfWctBfVdmjCIC8Qp-ewpeOY4,4126
-teelebot/__main__.py,sha256=s_E7-RSOfVOZx7c84WupirrRB3zuMwtNDqi6o2Ij0Ko,159
-teelebot/bot.py,sha256=C8eLh2B3l1GxjnHpQtObZL0vqcFkBEcxRJC6y4fkwzs,27942
-teelebot/buffer.py,sha256=yn0CBGUbPBbXmERjMTuCeKZaM_y7H0gPsJbrxiRKliY,7366
-teelebot/handler.py,sha256=ZPVuqeat6bIenPQL9AjAcYbyQ190ElELecKuVdznwX4,19377
+teelebot/__main__.py,sha256=_j6f3hj0VtlcCsabcIvuS0uBI0NVbCVwmH138tqYGFo,165
+teelebot/bot.py,sha256=QWqYYWhmUUxGbYHjOjjZphL1Uj_O8hMGlrEMZ5SakNs,31926
+teelebot/buffer.py,sha256=YS69_8lqrzZp0WCideDY1nsuNZCGCRguz6KlZsjdvxA,7802
+teelebot/handler.py,sha256=_XoyJfQYSQM9pDNvg7hKo3xNqrqbTQNt7mhd3cm8oYg,21867
 teelebot/logger.py,sha256=_QWA2Kbj-JWNYDtgeK6IE7q34Brxrq6cUgHEH4YTu2M,1807
 teelebot/polling.py,sha256=7lPDDeVInhk8MH-ZQhzGXYW-uI5t-F0XtMYkMrcEDEU,721
 teelebot/request.py,sha256=aYrdPV-IRJPdiZgZlIjU4es8QokOzs8Jn_bZVd_aI3I,3700
-teelebot/schedule.py,sha256=zMozNsMfsm__ss7samHDmpjXuAyrdBxTQOU1f5wcXXo,3895
-teelebot/version.py,sha256=POwd5wx29VzhhtkRfLzgojqDv4-6vjVKIL_FafJfhK8,482
+teelebot/schedule.py,sha256=GGcFlEwpfO254D-2-ALBdAv539i97r_nAUnCJLBnA4o,4075
+teelebot/version.py,sha256=YzTDbJBL3pDhc5ICyZ3Oy1X4jPucTjIH-bCTtTF9oFA,482
 teelebot/webhook.py,sha256=IomyaLxak_caDNYKNnLaTLtqkFToYq4sHWsD7kahV4Y,2665
-teelebot-2.0.3.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-teelebot-2.0.3.dist-info/METADATA,sha256=NTpVnOuWUtZTfOj4tfTmlyyFOEI_Oq7APIKCwUUXbFI,9052
-teelebot-2.0.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-teelebot-2.0.3.dist-info/entry_points.txt,sha256=IZHSiwFVJ6BPPTW3j7I1i34AESCOPaTYiC1qoWfpj6k,43
-teelebot-2.0.3.dist-info/top_level.txt,sha256=vMgTMVZJd4P3KjMwVpgWfIUvNLYKqfyHO4Cul-YwuyQ,9
-teelebot-2.0.3.dist-info/zip-safe,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
-teelebot-2.0.3.dist-info/RECORD,,
+teelebot-2.1.0.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
+teelebot-2.1.0.dist-info/METADATA,sha256=FgXovssbpbKCYPmZ2KejITaUCOJ0I2-CA6SQM0WyQ74,9052
+teelebot-2.1.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+teelebot-2.1.0.dist-info/entry_points.txt,sha256=IZHSiwFVJ6BPPTW3j7I1i34AESCOPaTYiC1qoWfpj6k,43
+teelebot-2.1.0.dist-info/top_level.txt,sha256=vMgTMVZJd4P3KjMwVpgWfIUvNLYKqfyHO4Cul-YwuyQ,9
+teelebot-2.1.0.dist-info/zip-safe,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
+teelebot-2.1.0.dist-info/RECORD,,
```

